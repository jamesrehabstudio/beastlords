<html>
<head>
	<script src="game.js"></script>
	<script src="polygons.js"></script>
	<script>
function Matrix(w, h) {
	this._m = new Array();
	this.width = w;
	this.height = h;
	for(var x=0; x< this.width; x++ ){
		for(var y=0; y<this.height; y++ ){
			this._m.push( false );
		}
	}
}
Matrix.prototype.tile = function(x,y,value) {
	if( x < 0 || x >= this.width || y < 0 || y >= this.height ) {
		return; 
	}
	var index = ( x * this.height ) + y;
	if ( value != undefined ) {
		this._m[index] = value;
	} 
	
	return this._m[index];	
}
	</script>
	
	<script>
var world;
var canvas;
var perimeter;
var bounds;
window.onload = function() {
	canvas = document.getElementById( 'canvas' );
	world = new Game( canvas );
	world.camera.x = -290;
	world.camera.y = -270;
	
	//create perimeter
	points_count = 15;
	size = 200;
	perimeter = new Polygon();
	for( var i = 0; i < points_count; i++ ) {
		var pos = i /  points_count;
		var angle = pos * ( 2 * Math.PI );
		
		perimeter.addPoint( new Point( 
			size * Math.sin( angle ),
			size * Math.cos( angle )
		) );
	}
	
	//Add medium points
	perimeter.jitter(1.2 * size);

	perimeter.jitter(0.5 * size);
	perimeter.jitter(0.5 * size);
	perimeter.subdivide();
	perimeter.jitter(0.5 * size);
	perimeter.merge(0.2 * size);
	perimeter.subdivide();
	perimeter.jitter(0.1 * size,5);
	perimeter.subdivide();
	perimeter.jitter(0.1 * size,5);
	perimeter.smooth();
	perimeter.merge(1);
	
	world.collisions = perimeter._lines;
	world.update();
	
	bounds = perimeter.bounds();
	
	var mount_count = 15;
	var mount_inc = 0;
	var mount_ranges = new Array();
	while( mount_inc < mount_count ) {
		mount = new Point( 
			bounds.start.x + (Math.random() * Math.abs( bounds.start.x - bounds.end.x ) ),
			bounds.start.y + (Math.random() * Math.abs( bounds.start.y - bounds.end.y ) )
		);
		mount.size = 25;
		mount.height = 4.0;
		if ( perimeter.intersects( mount ) ) {
			mount_inc++;
			mount_ranges.push( mount );
		}
	}
	var temp = new Array();
	for(var i=0;i<mount_ranges.length;i++){
		var peaks = 3 + ~~( Math.random() * 5 );
		for(var j=0;j<peaks;j++){
			var angle = Math.random() * 2 * Math.PI;
			var distance = Math.random() * size * 0.1;
			temp_m = new Point( 
				mount_ranges[i].x + (Math.sin( angle ) * distance), 
				mount_ranges[i].y + (Math.cos( angle ) * distance) 
			);
			temp_m.size = 50;
			temp_m.height = 5.0;
			temp.push( temp_m );
		}
	}
	mount_ranges = mount_ranges.concat( temp );
	
	world.g.fillStyle = "#000";
	var rivers = new Array();
	var lakes = new Array();
	window.m = new Matrix(~~Math.abs(bounds.start.x-bounds.end.x), ~~Math.abs(bounds.start.y-bounds.end.y) );
	for(var x=0; x<m.width;x++){
		for(var y=0; y<m.height;y++){
			
			var tile = {x:x,y:y,height:0,sea:false};
			var position = new Point(x+bounds.start.x,y+bounds.start.y)
			var land = perimeter.intersects(position);
			
			if ( land ) {
				var h = 0;
				for(var i=0;i<mount_ranges.length;i++){					
					var temp_h = Math.max( mount_ranges[i].height - ( (mount_ranges[i].size / size) * mount_ranges[i].distance( position ) ), 1 );
					if( temp_h > h ){ h = temp_h }
				}
				h = h * ( 120 * ( perimeter.distanceFromEdge( position ) / size ) );
				if( Math.random() < ( h - 100 ) * 0.0000005 * size ){
					rivers.push( {start:position,flow:[],force:2.0} );
				}
				
				var c = ~~Math.max(Math.min( h, 255 ),0);
				tile.height = c;
				world.g.fillStyle = "RGB("+c+","+c+","+c+")";
				world.g.fillRect(
					~~(bounds.start.x+x-world.camera.x),
					~~(bounds.start.y+y-world.camera.y),
					1,1
				);
			} else {
				tile.sea = true;
			}
			
			m.tile(x,y, tile );
		}
	}
	
	for(var i=0;i<rivers.length;i++) {
		var x = ~~(rivers[i].start.x);
		var y = ~~(rivers[i].start.y);
		
		var angle = Math.random() * Math.PI * 2;
		var temp_x = 0;
		var temp_y = 0;
		var lake = false;
		for(var f=0;f<100;f++){
			var lowest = 5000000;
			var lowest_tile = null;
			for(var a=0;a<Math.PI*2;a+=Math.PI/4) {
				//a += Math.random() * 0.1;
				test_x = x + ( Math.sin(a) * rivers[i].force );
				test_y = y + ( Math.cos(a) * rivers[i].force );
				var tile = m.tile(
					~~(test_x - bounds.start.x),
					~~(test_y - bounds.start.y)
				);
				if( tile ){
					if( tile.height < lowest ){
						lowest = tile.height;
						lowest_tile = tile;
						temp_x = test_x;
						temp_y = test_y;
					}
				}
			}
			//lowest_tile.height -= 1;
			lake = lowest_tile;
			var line = new Line(new Point(~~x,~~y),new Point(~~temp_x,~~temp_y) );
			rivers[i].flow.push( line );
			x = temp_x;
			y = temp_y;
			line.render(world.g,world.camera);
			
			if ( lowest_tile.sea ) { lake = false; break; }
		}
		
		if ( lake ) {
			lakes.push( lake );
		}
	}
	
	for( var i=0; i < lakes.length; i++ ){
		fillLake(lakes[i], m, lakes[i].height + 5);
	}
	console.log( lakes );
}

function fillLake(tile, m, h, levels ) {
	if ( !tile || levels < 1 ) return;
	levels = levels - 1 || 200;
	world.g.fillStyle = "#3AF";
	
	var r = 0, i = 0, c = 0;
	var previous = [ tile ];
	while( r < 9 ) {
		r++;
		c = r * 8;
		
		for( var x = 0; x < (r*2+1); x++ ){
			for( var y = 0; y < (r*2+1); y++ ){
				var _xoff = tile.x + x - r;
				var _yoff = tile.y + y - r;
				var t = m.tile(_xoff, _yoff );
				
				if( t.height < h ){
					world.g.fillRect(
						(_xoff+world.camera.x)-bounds.start.x, 
						(_yoff+world.camera.y)-bounds.start.y, 
						1, 1 );
				}
				
				if(y==0&&x!=0&&x!=(r*2)){ y=(r*2)-1; }
			}
		}
	}
}

Polygon.prototype.smooth = function( strength ){
	var temp = new Array();
	for( var i = 0; i < this.points.length; i++ ) {
		var prev_index = i == 0 ? this.points.length - 1 : i - 1;
		prev = this.points[prev_index];
		current = this.points[i];
		next = this.points[ (i + 1) % this.points.length ];
		
		mid = new Point( 
			( prev.x + current.x + next.x ) / 3,
			( prev.y + current.y + next.y ) / 3
		);
		
		temp.push( mid );
	}
	this.points = temp;
	this._rebuildLines();
}

Polygon.prototype.jitter = function( strength, times ){
	times = times || 0;
	for( var i = 0; i < this.points.length; i++ ) {
		this.points[i].x += (Math.random() - 0.5) * strength;
		this.points[i].y += (Math.random() - 0.5) * strength;
	}
	this._rebuildLines();
	
	if ( times > 0 ) {
		this.jitter(strength, times - 1 );
	}
}

Polygon.prototype.merge = function( threshold ){
	threshold = threshold || 0.00000001;
	var temp = new Array();
	for( var i = 0; i < this.points.length; i++ ) {
		if ( temp.length > 0 ) {
			var prev = temp[temp.length - 1];
			if ( this.points[i].distance( prev ) > threshold ) {
				temp.push( this.points[i] );
			}
		}else {
			temp.push( this.points[i] );
		}
	}
	console.log ( "Merged "+ (this.points.length - temp.length) +" points" );
	this.points = temp;
	this._rebuildLines();
}

Polygon.prototype.bounds = function(){
	if ( this.points.length < 1 ) {
		return false;
	}
	var top_left = new Point( this.points[0].x, this.points[0].y );
	var bottom_right = new Point( this.points[0].x, this.points[0].y );
	
	for( var i = 0; i < this.points.length; i++ ) {
		if ( this.points[i].x < top_left.x ) { top_left.x = this.points[i].x }
		if ( this.points[i].y < top_left.y ) { top_left.y = this.points[i].y }
		if ( this.points[i].x > bottom_right.x ) { bottom_right.x = this.points[i].x }
		if ( this.points[i].y > bottom_right.y ) { bottom_right.y = this.points[i].y }
	}
	return new Line( top_left, bottom_right );
}

Polygon.prototype.subdivide = function(){
	var temp = new Array();
	for( var i = 0; i < this.points.length; i++ ) {
		var prev_index = i == 0 ? this.points.length - 1 : i - 1;
		prev = this.points[prev_index];
		current = this.points[i];
		next = this.points[ (i + 1) % this.points.length ];
		
		mid1 = new Point( 
			( current.x + prev.x ) * 0.5,
			( current.y + prev.y ) * 0.5
		);
		
		mid2 = new Point( 
			( current.x + next.x ) * 0.5,
			( current.y + next.y ) * 0.5
		);
		
		mid3 = new Point( 
			( current.x + mid1.x + mid2.x ) / 3,
			( current.y + mid1.y + mid2.y ) / 3
		);
		
		temp.push( mid3 );
		temp.push( mid2 );
	}
	this.points = temp;
	this._rebuildLines();
}

Polygon.prototype.distanceFromEdge = function(p){
	var dis = 99999999999999999999;
	for( var i = 0; i < this.points.length; i++ ) {
		temp = this.points[i].distance(p);	
		if( temp < dis ) { dis = temp; }
	}
	return dis;
}
	</script>
</head>
<body>
	<canvas id="canvas" width="600" height="600" style="background:#FED"></canvas>
</body>
</html>	