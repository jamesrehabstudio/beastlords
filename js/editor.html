<html>
<head>
	<style>
		*{margin:0;padding:0;} 
		body { 
			font-family:arial; 
			font-size:12px;
		}
		#menu {
			position:fixed;
			width:180px;
			height:100%;
			background:#ADCCFF;
			padding:10px;
		}
		#menu .input {
			margin-bottom:10px;
		}
		textarea {
			width:100%;
			margin-bottom:5px;
		}
		#tile_select {
			background:#FFF;
			height:180px;
			border:1px solid #AAA;
			overflow:auto;
			padding:10px;
		}
		#tile_select li {
			float:left;
			width:24px;
			height:32px;
			border:1px solid #AAA;
			margin:0 5px 5px 0;
			padding:4px;
			cursor:pointer;
		}
		#tile_select li img {
			width:24px;
			max-height:32px;
		}
		#tile_select li.active {
			border:1px solid #FD0;
		}
		
		#menu .area {
			border:1px solid #AAA;
			background:#FFF;
			padding:20px 10px 10px;
			position:relative;
			margin-bottom:10px;
		}
		#menu .area h2 {
			border:1px solid #AAA;
			background:#FFF;
			padding:5px;
			font-size:12px;
			position:absolute;
			top:-10px;
		}
		#thing_type, #test_paths {
			display:block;
			width:100%;
		}
		#status {
			position:fixed;
			bottom:0px;
			left:0px;
			background:#CCD;
			height:20px;
			width:100%;
			z-index:10;
		}
		#status>div {
			float:left;
			padding:4px 5px;
			margin:1px;
			height:8px;
			border:1px dotted #AAB;
		}
	</style>
	<script src="polygons.js"></script>
	<script src="data.js"></script>
	<script src="game.js"></script>
	<script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
	<script>
window.onresize = function() {
	if ( game != undefined ) {
		game.g.canvas.width  = window.innerWidth;
		game.g.canvas.height = window.innerHeight;
		render();
	}
}
	
render = function() {
	game.update();
	
	if ( selected_thing ) {
		game.g.setStrokeColor( "#FF0000" );
		game.g.strokeRect( 
			( selected_thing.position.x - selected_thing.sprite.offset.x ) - ( game.camera.x ),
			( selected_thing.position.y - selected_thing.sprite.offset.y ) - ( game.camera.y ),
			selected_thing.sprite.frame_width,
			selected_thing.sprite.frame_height
		);
	}
		
}

save = function(){
	var name = document.getElementById('map_name').value;
	document.getElementById('save_button').value = "Saving";

	var objects = "";
	for( var i=0; i<game.objects.length;i++){
		obj = game.objects[i];
		var prop = encodeURI(obj.properties);
		objects += '{"x":'+obj.position.x+',';
		objects += '"y":'+obj.position.y+',';
		objects += '"type":"'+obj.type+'",';
		objects += '"sprite":"'+obj.sprite.name+'",';
		objects += '"properties":"'+prop+'"},';
	}
	objects = objects.substr(0,objects.length-1);
	
	var lines = "";
	for( var i=0; i<game.collisions.length;i++){
		line = game.collisions[i];
		lines += '{"start_x":'+line.start.x+',';
		lines += '"start_y":'+line.start.y+',';
		lines += '"end_x":'+line.end.x+',';
		lines += '"end_y":'+line.end.y+'},';
	}
	lines = lines.substr(0,lines.length-1);
	out = '{"data":{"name":"'+name+'","objects":['+objects+'],"collisions":['+lines+']}}';
	
	$.ajax( {
		"url":"/save.php",
		"type":"POST",
		"data": { "name":name,data:out },
		complete : function() {
			document.getElementById('save_button').value = "Save";
		}
	} )
}

window.onkeydown = function(e){
	//console.log( e.keyCode );
	if ( _typing ){
		return;
	}
	
	if ( e.keyCode == 45 || e.keyCode == 36 ) {
		//Insert or Home
		e.preventDefault();
		var copy = e.keyCode == 36;
		
		if ( mode != MODE_LINES ) {
			if ( selected_sprite != null || copy ) {
				temp = new EditObject();
				temp.position.x = mouse_snap_x;
				temp.position.y = mouse_snap_y;
				temp.sprite = selected_sprite;
				if ( copy ) {
					if ( selected_thing != null ) {
						temp.type = selected_thing.type;
						temp.sprite = selected_thing.sprite;
						temp.properties = selected_thing.properties;
						game.addObject( temp );
						selected_thing = temp;
					}
				} else {
					temp.type = ( mode == MODE_TILES ? "Tile" : ( mode == MODE_PROPS ? "Prop" : "GameObject" ) );
					game.addObject( temp );
					selected_thing = temp;
				}
				render();
			}
		} else {
			if ( e.keyCode == 36 ) {
				if ( selected_line instanceof Line ){
					var temp = selected_line.start;
					selected_line.start = selected_line.end;
					selected_line.end = temp;
					render();
				}
			} else {
				temp = new Line(
					new Point(mouse_snap_x,mouse_snap_y),
					new Point(mouse_snap_x,mouse_snap_y) );
				selected_line = temp;
				selected_line_side = 2;
				game.collisions.push( temp );
				render();
			}
		}
	} else if ( e.keyCode == 46 ) {
		//Delete
		if ( mode != MODE_LINES ) {
			if ( selected_thing ) {
				game.objects.remove( game.objects.indexOf( selected_thing ) );
				selected_thing = null;
				render();
			}
		} else {
			if ( selected_line instanceof Line ) {
				game.collisions.remove( game.collisions.indexOf( selected_line ) );
				selected_line = null;
				render();
			}
		}
	} else if ( e.keyCode == 32 ) {
		//Space
		camera_drag = new Point( game.camera.x + abs_x, game.camera.y + abs_y );
	}
}
window.onkeyup = window.onblur = function(e){
	if( e instanceof KeyboardEvent ) {
		if ( e.keyCode == 32 ) { camera_drag = false; }
	} else {
		camera_drag = false;
	}
}

var canvas, g;
var game;
var abs_x, abs_y;
var mouse_x, mouse_y;
var mouse_snap_x, mouse_snap_y
var selected_thing = null;
var selected_sprite = null;
var camera_drag = false;
var type_field, prop_field, test_paths;
var mode = 0;

var MODE_TILES = 0;
var MODE_PROPS = 1;
var MODE_OBJECTS = 2;
var MODE_LINES = 3;

var selected_line, selected_line_side;
var _typing = false;
var typelock =  function(){ _typing = true; }
var typeunlock =  function(){ _typing = false; }

window.onload = function(){
	canvas = document.getElementById( 'canvas' );
	type_field = document.getElementById( 'thing_type' );
	prop_field = document.getElementById( 'thing_props' );
	test_paths = document.getElementById( 'test_paths' );
	prop_field.onfocus = typelock;
	prop_field.onblur = typeunlock;
	
	prop_field.oninput = function(e){
		if ( selected_thing ) {
			selected_thing.properties = this.value;
			render();
		}
	}
	test_paths.onclick = function(e){
		e.preventDefault();
		buildPaths();
		render();
	}
	RT = "../";
	
	RT = "../";
	dataManager = new DataManager();
	window.game = new Game( canvas );
	window.game.camera.x = 160;
	window.game.camera.y = 120;
	load_sprites();
	
	//add sprites to sprite_select
	sprite_select = document.getElementById( 'tile_select' );
	for( var i in sprites ) {
		var temp = document.createElement('li');
		var image = document.createElement('img');
		image.src = sprites[i].img.src;
		temp.sprite = sprites[i];
		temp.appendChild( image );
		temp.onclick = function(e){
			window.selected_sprite = this.sprite;
			$('#tile_select li').removeClass('active');
			$(this).addClass('active');
			return false;
		}
		sprite_select.appendChild( temp );
	}
	
	canvas.onmousemove = function(e){
		abs_x = e.pageX;
		abs_y = e.pageY;
		mouse_x = abs_x + game.camera.x;
		mouse_y = abs_y + game.camera.y;
		
		if ( camera_drag instanceof Point ) {
			game.camera.x = camera_drag.x - abs_x;
			game.camera.y = camera_drag.y - abs_y;
			render();
			return false;
		}
		
		var snap = Math.max( document.getElementById( 'grid_snap' ).value, 1 );
		mouse_snap_x = Math.floor( mouse_x / snap ) * snap;
		mouse_snap_y = Math.floor( mouse_y / snap ) * snap;
		
		$('#cursor_pos').html(mouse_snap_x+'x : '+mouse_snap_y+'y');
		
		if ( window.drag && selected_thing ) {
			selected_thing.position.x = Math.floor( (mouse_x - drag.x) / snap ) * snap;
			selected_thing.position.y = Math.floor( (mouse_y - drag.y) / snap ) * snap;
			render();
		}
		if ( window.selected_line && window.selected_line_side ) {
			var _side = window.selected_line_side == 1 ? 'start' : 'end';
			selected_line[_side].x = mouse_snap_x;
			selected_line[_side].y = mouse_snap_y;
			render();
		}
	}
	canvas.onmouseup = canvas.onblur = function(e){
		window.drag = false;
		window.selected_line_side = false;
	};
	canvas.onmousedown = function(e){
		mouse = new Point( mouse_x, mouse_y );
		
		if( mode != MODE_LINES ){
			//Find clicked on Tile
			largest_zIndex = -Math.pow( 10, 10 );
			for( var i=0; i < game.objects.length; i++ ) {
				var object =  game.objects[i];
				if ( matchMode( object ) ) {
					//The object is a prop (if prop mode) a tile (if Tile mode), etc.
					var zIndex = object.zIndex || object.position.y;
					if ( object.isOver( mouse ) && zIndex > largest_zIndex ) {
						selected_thing = object;
						render();
						window.drag = new Point(
							mouse_x - object.position.x,
							mouse_y - object.position.y
						);
						largest_zIndex = zIndex;
					}
				}
			}
		} else {			
			//Find line end clicked on
			for( var i = 0; i < game.collisions.length; i++ ) {
				var line = game.collisions[i];
				if ( line.start.distance( mouse ) < 10 ) {
					selected_line = line;
					selected_line_side = 1;
				} else if ( line.end.distance( mouse ) < 10 ) {
					selected_line = line;
					selected_line_side = 2;
				}
				console.log( line );
			}
		}
		
		if ( selected_thing ){ 
			type_field.value = selected_thing.type; 
			prop_field.value = selected_thing.properties; 
		}
		
		$('input, textarea').blur();
		return false;
	}
	type_field.onclick = function(e){
		if ( selected_thing ){
			var type = prompt( "Set Thing Type", selected_thing.type );
			this.value = type;
			selected_thing.type = type;
		}
	}
	document.getElementById('load_button').onclick = function(){
		var map = prompt("Enter map name");
		if ( map ) {
			dataManager.getLevel( function( res ) {
				window.game = new Game( canvas );
				window.game.camera.x = 160;
				window.game.camera.y = 120;
				
				for( var i = 0; i < res.data.objects.length; i++ ){
					var prop = decodeURI(res.data.objects[i].properties);
					temp = new EditObject();
					temp.position.x = res.data.objects[i].x;
					temp.position.y = res.data.objects[i].y;
					temp.type = res.data.objects[i].type;
					temp.sprite = sprites[ res.data.objects[i].sprite ];
					temp.properties = prop;
					window.game.addObject( temp );
				}
				
				for( var i = 0; i < res.data.collisions.length; i++ ){
					var line = res.data.collisions[i];
					temp = new Line( 
						new Point( line.start_x, line.start_y ),
						new Point( line.end_x, line.end_y )
					);
					window.game.collisions.push( temp );
				}
				
				document.getElementById('map_name').value = res.data.name;
				render();
			}, window, map );
		}
	}
	
	document.getElementById('save_button').onclick = save;
	
	document.getElementById('toggle_mode').onclick = function(){
		mode = ( mode + 1 ) % 4
		if ( mode == MODE_TILES ) { this.value = "Tile Mode"; }
		if ( mode == MODE_PROPS ) { this.value = "Prop Mode"; }
		if ( mode == MODE_OBJECTS ) { this.value = "Object Mode"; }
		if ( mode == MODE_LINES ) { this.value = "Line Mode"; }
	};
}


EditObject.prototype = new GameObject();
EditObject.prototype.constructor = GameObject;

function EditObject(x, y){
	this.constructor();
}
EditObject.prototype.isOver = function( p ){ 
	var out = (
	p.x > this.position.x - this.sprite.offset.x && 
	p.y > this.position.y - this.sprite.offset.y &&
	p.x < this.position.x + this.sprite.frame_width && 
	p.y < this.position.y + this.sprite.frame_height );
	return out;
}
EditObject.prototype.render = function(g,c){
	if ( this.type == "Node" ){
		var props = {};
		try{ props = JSON.parse( this.properties ) } catch(e){};
		g.beginPath();
		g.strokeStyle = "#FF00FF";
		var width = props.width || 32;
		var height = props.height || 32;
		g.strokeRect(
			(this.position.x-(.5*width))-c.x,
			(this.position.y-(.5*height))-c.y,
			width, height
		);
		if ( props.lock instanceof Array ){
			g.arc(
				this.position.x-c.x,
				this.position.y-c.y,
				Math.min(width,height)*.5,
				0, Math.PI*2,true
			);
			g.stroke();  
			g.closePath();
		}
		if ( selected_thing == this ) {
			if ( props.lock instanceof Array && props.lock.length >= 4 ){
				g.strokeStyle = "#FFDD00";
				g.strokeRect(
					props.lock[3]-c.x, props.lock[0]-c.y,
					props.lock[1]-props.lock[3], props.lock[2]-props.lock[0]
				);
			}
		}
	} else {
		GameObject.prototype.render.apply(this,[g,c]);
	}
	
	if( this.connections instanceof Array ){
		g.strokeStyle = "#FFDD00";
		for(var i=0;i<this.connections.length;i++){
			g.beginPath();
			g.moveTo(this.position.x-c.x,this.position.y-c.y);
			g.lineTo(this.connections[i].position.x-c.x,this.connections[i].position.y-c.y);
			g.stroke();
			g.closePath();
		}
	}
}

function matchMode( object ) {
	if ( mode == MODE_TILES ) {
		return object.type == "Tile";
	}else if ( mode == MODE_PROPS ) {
		return object.type == "Prop";
	}else if ( mode == MODE_OBJECTS ) {
		return ( object.type != "Tile" && object.type != "Prop" );
	}
	return false;
}
	</script>
</head>
<body>
	<div id="menu">
		<div class="input">
			<label for="grid_snap">Grid Snap</label>
			<input type="text" id="grid_snap" value="8" />
		</div>
		<div class="input">
			<label for="toggle_mode">Mode</label>
			<input type="button" id="toggle_mode" value="Tile Mode" />
		</div>
		
		<div class="input">
			<label>Tile Select</label>
			<ul id="tile_select"></ul>
		</div>
		<div class="input">
			<label>Filter</label>
			<input type="text" id="tile_filter" />
		</div>
		
		<div class="area">
			<h2>Selected</h2>
			<label>Type</label>
			<input type="button" id="thing_type" name="type" />
			<label>Properties</label>
			<textarea id="thing_props"></textarea>
			<input type="button" id="test_paths" name="type" value="Test Paths" />
		</div>
		<div class="area">
			<h2>File</h2>
			<div class="input">
				<label>Map name</label>
				<input type="text" id="map_name" value="" />
			</div>
			
			<input type="submit" id="load_button" value="Load" />
			<input type="submit" id="save_button" value="Save" />
		</div>
	</div>
	<div id="status">
		<div id="cursor_pos"></div>
	</div>
	<canvas id="canvas" width="1200" height="1200" style="background:#FED"></canvas>
</body>
</html>	